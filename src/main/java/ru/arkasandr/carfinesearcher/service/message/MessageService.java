package ru.arkasandr.carfinesearcher.service.message;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.io.FileUtils;import org.springframework.core.io.ByteArrayResource;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.MediaType;import org.springframework.messaging.Message;import org.springframework.messaging.support.MessageBuilder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.LinkedMultiValueMap;import org.springframework.web.client.RestTemplate;import ru.arkasandr.carfinesearcher.config.props.GibddProperties;import ru.arkasandr.carfinesearcher.config.props.TelegramProperties;import ru.arkasandr.carfinesearcher.model.Car;import ru.arkasandr.carfinesearcher.model.GibddRequest;import ru.arkasandr.carfinesearcher.repository.ChatRepository;import ru.arkasandr.carfinesearcher.repository.GibddRequestRepository;import ru.arkasandr.carfinesearcher.service.GibddScrapService;import ru.arkasandr.carfinesearcher.service.message.dto.Answer;import ru.arkasandr.carfinesearcher.service.message.dto.CaptchaMessageRequestDto;import ru.arkasandr.carfinesearcher.service.message.dto.CaptchaMessageResponseDto;import ru.arkasandr.carfinesearcher.service.message.dto.GibddRequestMessageDto;import javax.persistence.EntityNotFoundException;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.text.MessageFormat;import java.time.LocalDate;import java.util.Objects;import java.util.stream.Collectors;import java.util.stream.Stream;import static java.time.LocalDateTime.now;import static java.util.Objects.isNull;import static org.apache.commons.lang3.StringUtils.isBlank;import static org.apache.commons.lang3.StringUtils.isNotBlank;import static ru.arkasandr.carfinesearcher.model.enums.RequestStatus.*;import static ru.arkasandr.carfinesearcher.telegram.constants.BotMessageEnum.EXCEPTION_CAPTCHA_MAX_ATTEMPT;import static ru.arkasandr.carfinesearcher.telegram.constants.BotMessageEnum.EXCEPTION_CAPTCHA_REPEAT;@RequiredArgsConstructor@Service@Slf4jpublic class MessageService {    private static final String SEND_PHOTO_KEY = "photo";    private static final String SEND_MESSAGE_KEY = "text";    private static final String PHOTO_NAME = "captcha";    private static final String PHOTO_EXT = ".png";    private static final String CAPTCHA_ERROR = "Проверка CAPTCHA";    private static final String CAPTCHA_EXPIRED = "\u274C Срок действия кода CAPTCHA устарел!";    private static final String ENTER_CAPTCHA_CODE = "\uD83D\uDD38 Введите проверочный код с изображения";    private static final String REPEAT_CAPTCHA_CODE = "\u274C Проверочный код не принят! Введите проверочный код с изображения еще раз";    private static final String INFORMATION = " \n Информация: ";    private static final String CHECKING_RESULT = " \n Результат проверки: ";    private static final String CHECKING_DATE = " \n Дата проверки: ";    private final MessageGateway gateway;    private final GibddScrapService scrapService;    private final RestTemplate restTemplate;    private final ChatRepository chatRepository;    private final GibddRequestRepository gibddRequestRepository;    private final GibddProperties gibddProperties;    private final TelegramProperties telegramProperties;    /**     * Метод отправляет запрос c данными о ТС в очередь для передачи парсеру (выполняется на стороне бота)     */    public void sendMessageToQueueWithCarData(Car car, GibddRequest request) {        var dto = GibddRequestMessageDto.builder()                .registrationNumber(car.getRegistrationNumber())                .certificateNumber(car.getCertificateNumber())                .uuid(request.getId())                .build();        var message = MessageBuilder                .withPayload(dto)                .build();        gateway.sendGibddRequestWithCarData(message);        log.debug("Request message with car data UUID = {} was sent to queue", request.getId());    }    /**     * Метод получает данные о ТС для парсера из очереди (выполняется на стороне парсера)     */    public void receiveMessageFromQueueWithCarData(Message<String> message) {        var messagePayload = message.getPayload();        var mapper = new ObjectMapper();        try {            var dto = mapper.readValue(messagePayload, GibddRequestMessageDto.class);            log.debug("Response message with car data UUID = {} was received from queue", dto.getUuid().toString());            var captchaMessageRequest = scrapService.scrapCaptcha(dto, null);            sendCaptchaRequestToUser(captchaMessageRequest);            log.debug("Request message UUID = {} with captcha was send to user", captchaMessageRequest.getUuid().toString());        } catch (JsonProcessingException e) {            log.error("Exception during receiveMessageFromQueueWithCarData:", e);        }    }    /**     * Метод отправляет запрос в очередь c captcha для распознования пользователем (выполняется на стороне парсера)     */    public void sendCaptchaRequestToUser(CaptchaMessageRequestDto captchaMessageRequestDto) {        var message = MessageBuilder                .withPayload(captchaMessageRequestDto)                .build();        gateway.sendCaptchaRequestToUser(message);        log.debug("Request message UUID = {} was sent to queue", captchaMessageRequestDto.getUuid());    }    /**     * Метод получает запрос из очереди c captcha для распознавания пользователем (выполняется на стороне бота)     * и отсылает их пользователю     */    @Transactional    public void receiveMessageFromQueueWithCaptcha(Message<String> message) {        var messagePayload = message.getPayload();        var url = telegramProperties.getUrl();        var botToken = telegramProperties.getToken();        var mapper = new ObjectMapper();        try {            var dto = mapper.readValue(messagePayload, CaptchaMessageRequestDto.class);            var captchaMessage = isBlank(dto.getMessage())                    ? ENTER_CAPTCHA_CODE                    : REPEAT_CAPTCHA_CODE;            log.debug("Response message UUID = {} was received from queue", dto.getUuid().toString());            var chat = chatRepository.findChatByRequestUUID(dto.getUuid())                    .orElseThrow(EntityNotFoundException::new);            byte[] content = dto.getCaptcha();            LinkedMultiValueMap<String, Object> map = new LinkedMultiValueMap<>();            map.add(SEND_PHOTO_KEY, createPhotoResource(content, PHOTO_NAME, PHOTO_EXT));            map.add("caption", captchaMessage);            HttpHeaders headers = new HttpHeaders();            headers.setContentType(MediaType.MULTIPART_FORM_DATA);            HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<>(map, headers);            log.debug("RestTemplateCaptcha picture start sending UUID = {} ", dto.getUuid().toString());            restTemplate.exchange(                    MessageFormat.format("{0}bot{1}/sendPhoto?chat_id={2}",                            url, botToken, chat.getChatId().toString()),                    HttpMethod.POST,                    requestEntity,                    String.class);            log.debug("Captcha picture message UUID = {} was send to User", dto.getUuid().toString());            var request = gibddRequestRepository.findById(dto.getUuid())                    .orElseThrow(() -> new EntityNotFoundException("Запрос с UUID = " + dto.getUuid() + " отсутствует!"));            request.setStatus(CAPTCHA_IS_WAITING);            request.setCaptchaPic(content);            gibddRequestRepository.save(request);        } catch (Exception e) {            log.error("Exception during receiveMessageFromQueueWithCaptcha:", e);        }    }    /**     * Метод отправляет запрос cо значением captcha в очередь для передачи парсеру (выполняется на стороне бота)     */    @Transactional    public void sendMessageToQueueWithCaptchaValue(GibddRequest request, String captcha) {        var dto = CaptchaMessageResponseDto.builder()                .uuid(request.getId())                .value(captcha)                .build();        var message = MessageBuilder                .withPayload(dto)                .build();        gateway.sendCaptchaResponseWithValue(message);        log.debug("CaptchaMessageResponse message UUID = {} was sent to queue with captcha value", request.getId());    }    /**     * Метод получает captcha с распознанным значением для парсера из очереди (выполняется на стороне парсера)     * и запускает поиск штрафов     */    public void receiveMessageFromQueueWithCaptchaValue(Message<String> message) {        var messagePayload = message.getPayload();        var maxCaptchaAttempt = gibddProperties.getMaxCaptchaAttempt();        var mapper = new ObjectMapper();        try {            var dto = mapper.readValue(messagePayload, CaptchaMessageResponseDto.class);            log.debug("CaptchaMessageResponse message with UUID = {} was received from queue", dto.getUuid().toString());            var existRequest = gibddRequestRepository.findById(dto.getUuid());            var captchaAttemptNumber = existRequest.map(GibddRequest::getCaptchaAttempt).orElse(null);            log.info("Starting captchaAttempt {} with UUID = {}", captchaAttemptNumber, dto.getUuid().toString());            var answer = scrapService.scrapFines(dto);            //перезапрашиваем captcha, если ответ вернулся с сообщением об ошибке или истекшим временем captcha            if (isNotBlank(answer.getCheckingMessage())                    && (answer.getCheckingMessage().startsWith(CAPTCHA_ERROR)                    || answer.getCheckingMessage().startsWith(CAPTCHA_EXPIRED))) {                if (!isNull(captchaAttemptNumber) && captchaAttemptNumber < maxCaptchaAttempt) {                    var captchaMessageRequestDto = scrapService.scrapCaptcha(null, answer.getUuid());                    captchaMessageRequestDto.setMessage(EXCEPTION_CAPTCHA_REPEAT.getMessage());                    sendCaptchaRequestToUser(captchaMessageRequestDto);                } else {                    log.info("MaxCaptchaAttempt {} with UUID = {}", captchaAttemptNumber, dto.getUuid().toString());                    var captchaMaxAttemptMessage = Answer.builder()                            .uuid(answer.getUuid())                            .checkingMessage(EXCEPTION_CAPTCHA_MAX_ATTEMPT.getMessage())                            .build();                    sendFinesToUser(captchaMaxAttemptMessage);                    scrapService.closePage(dto.getUuid());                }            } else {                sendFinesToUser(answer);                scrapService.closePage(dto.getUuid());            }        } catch (JsonProcessingException e) {            log.error("Exception during receiveMessageFromQueueWithCaptchaValue:", e);        }    }    /**     * Метод отправляет в очередь ответ с информацией о штрафах (выполняется на стороне парсера)     */    public void sendFinesToUser(Answer userAnswer) {        var message = MessageBuilder                .withPayload(userAnswer)                .build();        gateway.sendAnswerToUser(message);        log.debug("Response message UUID = {} with user's fines was sent to queue", userAnswer.getUuid());    }    /**     * Метод получает ответ из очереди с информацией о выполненном запросе - штрафах (выполняется на стороне бота)     * и отсылает их пользователю     */    public void receiveAnswerToUserFromQueue(Message<String> message) {        var messagePayload = message.getPayload();        var url = telegramProperties.getUrl();        var botToken = telegramProperties.getToken();        var mapper = new ObjectMapper();        try {            Answer dto = mapper.readValue(messagePayload, Answer.class);            log.debug("AnswerToUserResponse message with UUID = {} was received from queue", dto.getUuid().toString());            var chat = chatRepository.findChatByRequestUUID(dto.getUuid())                    .orElseThrow(EntityNotFoundException::new);            LinkedMultiValueMap<String, Object> map = new LinkedMultiValueMap<>();            HttpHeaders headers = new HttpHeaders();            HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<>(map, headers);            var userMessage = createMessageFromAnswer(dto);            map.add(SEND_MESSAGE_KEY, userMessage);            restTemplate.exchange(                    MessageFormat.format("{0}bot{1}/sendMessage?chat_id={2}",                            url, botToken, chat.getChatId().toString()),                    HttpMethod.POST,                    requestEntity,                    String.class);            log.debug("Answer with fines message UUID = {} was send to User", dto.getUuid().toString());            var existRequest = gibddRequestRepository.findById(dto.getUuid())                    .orElseThrow(() -> new EntityNotFoundException("Запрос с UUID = " + dto.getUuid() + " отсутствует!"));            if (dto.getCheckingMessage().startsWith(EXCEPTION_CAPTCHA_MAX_ATTEMPT.getMessage())) {                existRequest.setStatus(REJECTED);                existRequest.setResponseDate(now());                log.info("Request with UUID = {} was REJECTED", dto.getUuid().toString());            } else {                existRequest.setStatus(EXECUTED);                existRequest.setResponseDate(now());                log.info("Request with UUID = {} was EXECUTED", dto.getUuid().toString());            }            gibddRequestRepository.save(existRequest);        } catch (Exception e) {            log.error("Exception during receiveAnswerToUserFromQueue:", e);        }    }    private String createMessageFromAnswer(Answer answer) {        var checkingInfo = isNotBlank(answer.getCheckingInfo())                ? (INFORMATION).concat(answer.getCheckingInfo())                : null;        var checkingMessage = isNotBlank(answer.getCheckingMessage())                ? (CHECKING_RESULT).concat(answer.getCheckingMessage())                : null;        var checkingDate = isNotBlank(answer.getCheckingDate())                ? answer.getCheckingDate()                : (CHECKING_DATE).concat(LocalDate.now().toString());        return Stream.of(checkingInfo, checkingMessage, checkingDate)                .filter(Objects::nonNull)                .collect(Collectors.joining("; ", "", "\n"));    }    /**     * Использование ByteArrayResource делает обязательным переопределение метода String getFilename()     */    public static ByteArrayResource createPhotoResource(byte[] photo, String name, String suffix) throws IOException {        return new ByteArrayResource(Files.readAllBytes(createOfficeDocumentFile(photo, name, suffix))) {            @Override            public String getFilename() {                return MessageFormat.format("{0}.{1}", name, suffix);            }        };    }    private static Path createOfficeDocumentFile(byte[] photo, String name, String suffix) throws IOException {        File file = File.createTempFile(name, suffix);        FileUtils.writeByteArrayToFile(file, photo);        return file.toPath();    }}